{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dicas de Django ! \u00b6 Site est\u00e1tico hospedado com github pages para salvar algumas dicas de Django e Django Rest Framework para problemas comuns, novos e desconhecidos que me deparo no meu dia a dia e possa ser \u00fatil futuramente para mim e qualquer outra pessoa. Enjoy ! Escolha uma dica abaixo: Django Configurar ambiente django para usar imagens Mover django model de um app para outro Django rest UrlField com v\u00e1rios lookups","title":"Home"},{"location":"#dicas-de-django","text":"Site est\u00e1tico hospedado com github pages para salvar algumas dicas de Django e Django Rest Framework para problemas comuns, novos e desconhecidos que me deparo no meu dia a dia e possa ser \u00fatil futuramente para mim e qualquer outra pessoa. Enjoy ! Escolha uma dica abaixo: Django Configurar ambiente django para usar imagens Mover django model de um app para outro Django rest UrlField com v\u00e1rios lookups","title":"Dicas de Django !"},{"location":"imagem/","text":"Imagens com Django e Django Rest Framework \u00b6 Ajustes para usar corretamento imagem com Django e o Django Rest Framework Imagens com Django \u00b6 Antes de tudo \u00e9 preciso fazer alguns ajuses na aplica\u00e7\u00e3o para utilizar as imagens da maneira correta com o django. Adicionar MEDIA_URL e MEDIA_ROOT no arquivo settings.py Adicionar MEDIA_URL e MEDIA_ROOT nas urlpatterns do arquivo urls.py do project. Settings.py \u00b6 Adicione as seguinte vari\u00e1veis de configura\u00e7\u00e3o no seu settings: MEDIA_URL = '/pasta_para_guardar_arquivos/' MEDIA_ROOT = os . path . join ( BASE_DIR , 'pasta_para_guardar_arquivos' ) MEDIA_URL : nome da pasta onde ser\u00e1 guardada as imagens, os v\u00eddeos e os arquivos que forem feito upload para o reposit\u00f3rio. MEDIA_ROOT : caminho absoluto para a pasta MEDIA_URL O seu reposit\u00f3rio ficar\u00e1 com a seguinte estrutura - repositorio - projeto - settings.py ... - app - models.py ... - pasta_para_guardar_arquivos ... - manage.py Onde pasta_para_guardar_arquivos ser\u00e1 o diret\u00f3rio para armazenar todos os arquivos que forem feito upload. Urls.py \u00b6 Concatene com a lista o seguintes comando: static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) Veja: # importa funcao static do django from django.conf.urls.static import static # importa as variaveis do arquivo settings.py from django.conf import settings urlpatterns = [ path ( '' , views ), ] + static ( settings . MEDIA_URL , document_root = settings . MEDIA_ROOT ) # concatena as rotas para acessar as imagens no servidor Models.py \u00b6 Adicionar campo de imagem ao Model from django.db import models class ModelComImagem ( models . Model ): imagem = models . ImageField ( upload_to = 'pasta_das_imagens/' ) o atributo upload_to recebe como par\u00e2metro uma string com o nome da pasta de destino. Esta pasta ser\u00e1 localizada dentro da pasta MEDIA_URL configurada nos settings.py . Ao salvar uma imagem voc\u00ea ter\u00e1 o seguinte diret\u00f3rio: - repositorio - projeto - settings.py ... - app - models.py ... - pasta_para_guardar_arquivos - pasta_das_imagens - imagem 1 .jpg ... - manage.py J\u00e1 que a string ser\u00e1 concatenada com a MEDIA_URL , \u00e9 poss\u00edvel criar subdiret\u00f3rios para upload_to . Por exemplo, imagine que sejam imagens de perfil do usu\u00e1rio, voc\u00ea pode fazer da seguinte forma: from django.db import models class ModelComImagem ( models . Model ): imagem = models . ImageField ( upload_to = 'perfil/pasta_das_imagens/' ) Agora, ao salvar voc\u00ea ter\u00e1 o seguinte diret\u00f3rio: - repositorio - projeto - settings.py ... - app - models.py ... - pasta_para_guardar_arquivos - perfil - pasta_das_imagens - imagem 1 .jpg ... ... - manage.py","title":"Configurar ambiente django para usar imagens"},{"location":"imagem/#imagens-com-django-e-django-rest-framework","text":"Ajustes para usar corretamento imagem com Django e o Django Rest Framework","title":"Imagens com Django e Django Rest Framework"},{"location":"imagem/#imagens-com-django","text":"Antes de tudo \u00e9 preciso fazer alguns ajuses na aplica\u00e7\u00e3o para utilizar as imagens da maneira correta com o django. Adicionar MEDIA_URL e MEDIA_ROOT no arquivo settings.py Adicionar MEDIA_URL e MEDIA_ROOT nas urlpatterns do arquivo urls.py do project.","title":"Imagens com Django"},{"location":"imagem/#settingspy","text":"Adicione as seguinte vari\u00e1veis de configura\u00e7\u00e3o no seu settings: MEDIA_URL = '/pasta_para_guardar_arquivos/' MEDIA_ROOT = os . path . join ( BASE_DIR , 'pasta_para_guardar_arquivos' ) MEDIA_URL : nome da pasta onde ser\u00e1 guardada as imagens, os v\u00eddeos e os arquivos que forem feito upload para o reposit\u00f3rio. MEDIA_ROOT : caminho absoluto para a pasta MEDIA_URL O seu reposit\u00f3rio ficar\u00e1 com a seguinte estrutura - repositorio - projeto - settings.py ... - app - models.py ... - pasta_para_guardar_arquivos ... - manage.py Onde pasta_para_guardar_arquivos ser\u00e1 o diret\u00f3rio para armazenar todos os arquivos que forem feito upload.","title":"Settings.py"},{"location":"imagem/#urlspy","text":"Concatene com a lista o seguintes comando: static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) Veja: # importa funcao static do django from django.conf.urls.static import static # importa as variaveis do arquivo settings.py from django.conf import settings urlpatterns = [ path ( '' , views ), ] + static ( settings . MEDIA_URL , document_root = settings . MEDIA_ROOT ) # concatena as rotas para acessar as imagens no servidor","title":"Urls.py"},{"location":"imagem/#modelspy","text":"Adicionar campo de imagem ao Model from django.db import models class ModelComImagem ( models . Model ): imagem = models . ImageField ( upload_to = 'pasta_das_imagens/' ) o atributo upload_to recebe como par\u00e2metro uma string com o nome da pasta de destino. Esta pasta ser\u00e1 localizada dentro da pasta MEDIA_URL configurada nos settings.py . Ao salvar uma imagem voc\u00ea ter\u00e1 o seguinte diret\u00f3rio: - repositorio - projeto - settings.py ... - app - models.py ... - pasta_para_guardar_arquivos - pasta_das_imagens - imagem 1 .jpg ... - manage.py J\u00e1 que a string ser\u00e1 concatenada com a MEDIA_URL , \u00e9 poss\u00edvel criar subdiret\u00f3rios para upload_to . Por exemplo, imagine que sejam imagens de perfil do usu\u00e1rio, voc\u00ea pode fazer da seguinte forma: from django.db import models class ModelComImagem ( models . Model ): imagem = models . ImageField ( upload_to = 'perfil/pasta_das_imagens/' ) Agora, ao salvar voc\u00ea ter\u00e1 o seguinte diret\u00f3rio: - repositorio - projeto - settings.py ... - app - models.py ... - pasta_para_guardar_arquivos - perfil - pasta_das_imagens - imagem 1 .jpg ... ... - manage.py","title":"Models.py"},{"location":"move_model_to_another/","text":"Mover django model de um app para outro \u00b6 Mover uma classe de um dos seus models de um django app para outro django app n\u00e3o \u00e9 uma tarefa trivial. Voc\u00ea ter\u00e1 que modificar os arquivos gerados pelo comando python3 manage.py makemigrations . Tendo em vista, decidi salvar aqui um breve tutorial com o passo a passo pra fazer isso. Estrutura do projeto \u00b6 Aqui abaixo est\u00e1 a estutura de diret\u00f3rio do projeto. congif/ settings.py wsgi.py core_application/ migrations/ 0001_initial.py admin.py app.py models.py tests.py views.py Preste aten\u00e7\u00e3o aos dois arquivos em destaque. Temos o migrations inicial do app core_aplication e o arquivo com os models ORM. O arquivo models.py \u00b6 Veja o arquivo models.py # models.py from django.db import models class Domain ( models . Model ): name = models . CharField ( max_length = 255 ) status = models . BooleanField ( default = True ) class Person ( models . Model ): name = models . CharField ( max_length = 255 ) Temos dois models: Domain , e Person . Dicidimos um dia que eles deve ser separados, cada em um sua apli\u00e7\u00e3o, e para isso criaremos uma nova aplica\u00e7\u00e3o: accounts com o camnando python3 manage.py startapp accounts congif/ settings.py wsgi.py core_application/ migrations/ 0001_initial.py admin.py app.py models.py tests.py views.py accounts/ migrations/ admin.py app.py models.py tests.py views.py Gerando os migrations \u00b6 O objetivo \u00e9 mover o model Person para a aplica\u00e7\u00e3o accounts , dessa forma core_aplication.Person --> accounts.Person . Primeiro criaremos um migration no app core_aplication para desvincular nosso model. core_application/ migrations/ 0001_initial.py 0002_untrack_model_person.py Pronto, criamos um arquivo de migrations onde podermos editar manualmente para criar uma estrat\u00e9gia para desvincular os models. Desvincular o model \u00b6 Veja como como deveremos fazer isso # 0002_untrack_model_person.py from django.db import migrations class Migration ( migrations . Migration ): dependencies = [ ( 'core_aplications' , '0001_initial' ), ] database_operations = [ migrations . AlterModelTable ( 'Person' , 'accounts_person' ) ] state_operations = [ migrations . DeleteModel ( 'Person' )] operations = [ migrations . SeparateDatabaseAndState ( database_operations = database_operations , state_operations = state_operations ) ] O codigo acima renomeia o nome da tabela do model Person , por\u00e9m essa renoa\u00e7\u00e3o \u00e9 feita a nivel de banco de dados, n\u00e3o altera o nome da tabela no c\u00f3digo o ORM. Em segida \u00e9 deletada a tabela do model Person , que tentar\u00e1 deletar uma tabela com o nome que n\u00e3o existe mais, o nome antigo, visto que a tabela foi renomeada, por\u00e9m o codigo ainda possui o nome da tebala antiga. Criar model da outra aplica\u00e7\u00e3o \u00b6 Agora criaremos o model na nova apli\u00e7\u00e3o. 1 - Cria classe do Model \u00b6 No arquivo copie e cole o arquivo do models.py da aplica\u00e7\u00e3o que estamos vendo, para a nova apli\u00e7\u00e3o. # core_application.models.py from django.db import models class Domain ( models . Model ): name = models . CharField ( max_length = 255 ) status = models . BooleanField ( default = True ) # accounts.models.py from django.db import models class Person ( models . Model ): name = models . CharField ( max_length = 255 ) 2 - Gerar novos migrations \u00b6 Execute o comando de makemigrations para o novo model: python3 manage.py makemigrations accounts Em seguida edite o novo arquivo de migration gerado e adicione as dependencias corretamente, e altere o atributo de operations, veja abaixo: class Migration ( migrations . Migration ): initial = True dependencies = [ # .... outras dependencias # adicione a dependencia da migration que criamos anteriormente # no app core_aplication ( 'core_aplication' , '0002_untrack_model_person' ) ] state_operations = [ # renomeio `operaionst para `state_operations` # oprations de Create gerado pelo # comando makemigrations accounts # com os campos do model, ou caso preferir, # que voc\u00ea tenha escrito. migrations . CreateModel ( name = 'Person' , fields = [ ( 'id' , models . AutoField ( auto_created = True , primary_key = True , serialize = False , verbose_name = 'ID' )), ( 'name' , models . CharField ( max_length = 255 )), ], options = { 'db_table' : 'accounts_person' , }, ), ] # alterere o atributo `operations` para utilizar o SeparateDatabaseAndState() # e passe como argumento o state_operations, onde criamos o model operations = [ migrations . SeparateDatabaseAndState ( state_operations = state_operations ) ] Model movido com sucesso!","title":"Mover django model de um app para outro"},{"location":"move_model_to_another/#mover-django-model-de-um-app-para-outro","text":"Mover uma classe de um dos seus models de um django app para outro django app n\u00e3o \u00e9 uma tarefa trivial. Voc\u00ea ter\u00e1 que modificar os arquivos gerados pelo comando python3 manage.py makemigrations . Tendo em vista, decidi salvar aqui um breve tutorial com o passo a passo pra fazer isso.","title":"Mover django model de um app para outro"},{"location":"move_model_to_another/#estrutura-do-projeto","text":"Aqui abaixo est\u00e1 a estutura de diret\u00f3rio do projeto. congif/ settings.py wsgi.py core_application/ migrations/ 0001_initial.py admin.py app.py models.py tests.py views.py Preste aten\u00e7\u00e3o aos dois arquivos em destaque. Temos o migrations inicial do app core_aplication e o arquivo com os models ORM.","title":"Estrutura do projeto"},{"location":"move_model_to_another/#o-arquivo-modelspy","text":"Veja o arquivo models.py # models.py from django.db import models class Domain ( models . Model ): name = models . CharField ( max_length = 255 ) status = models . BooleanField ( default = True ) class Person ( models . Model ): name = models . CharField ( max_length = 255 ) Temos dois models: Domain , e Person . Dicidimos um dia que eles deve ser separados, cada em um sua apli\u00e7\u00e3o, e para isso criaremos uma nova aplica\u00e7\u00e3o: accounts com o camnando python3 manage.py startapp accounts congif/ settings.py wsgi.py core_application/ migrations/ 0001_initial.py admin.py app.py models.py tests.py views.py accounts/ migrations/ admin.py app.py models.py tests.py views.py","title":"O arquivo models.py"},{"location":"move_model_to_another/#gerando-os-migrations","text":"O objetivo \u00e9 mover o model Person para a aplica\u00e7\u00e3o accounts , dessa forma core_aplication.Person --> accounts.Person . Primeiro criaremos um migration no app core_aplication para desvincular nosso model. core_application/ migrations/ 0001_initial.py 0002_untrack_model_person.py Pronto, criamos um arquivo de migrations onde podermos editar manualmente para criar uma estrat\u00e9gia para desvincular os models.","title":"Gerando os migrations"},{"location":"move_model_to_another/#desvincular-o-model","text":"Veja como como deveremos fazer isso # 0002_untrack_model_person.py from django.db import migrations class Migration ( migrations . Migration ): dependencies = [ ( 'core_aplications' , '0001_initial' ), ] database_operations = [ migrations . AlterModelTable ( 'Person' , 'accounts_person' ) ] state_operations = [ migrations . DeleteModel ( 'Person' )] operations = [ migrations . SeparateDatabaseAndState ( database_operations = database_operations , state_operations = state_operations ) ] O codigo acima renomeia o nome da tabela do model Person , por\u00e9m essa renoa\u00e7\u00e3o \u00e9 feita a nivel de banco de dados, n\u00e3o altera o nome da tabela no c\u00f3digo o ORM. Em segida \u00e9 deletada a tabela do model Person , que tentar\u00e1 deletar uma tabela com o nome que n\u00e3o existe mais, o nome antigo, visto que a tabela foi renomeada, por\u00e9m o codigo ainda possui o nome da tebala antiga.","title":"Desvincular o model"},{"location":"move_model_to_another/#criar-model-da-outra-aplicacao","text":"Agora criaremos o model na nova apli\u00e7\u00e3o.","title":"Criar model da outra aplica\u00e7\u00e3o"},{"location":"move_model_to_another/#1-cria-classe-do-model","text":"No arquivo copie e cole o arquivo do models.py da aplica\u00e7\u00e3o que estamos vendo, para a nova apli\u00e7\u00e3o. # core_application.models.py from django.db import models class Domain ( models . Model ): name = models . CharField ( max_length = 255 ) status = models . BooleanField ( default = True ) # accounts.models.py from django.db import models class Person ( models . Model ): name = models . CharField ( max_length = 255 )","title":"1 - Cria classe do Model"},{"location":"move_model_to_another/#2-gerar-novos-migrations","text":"Execute o comando de makemigrations para o novo model: python3 manage.py makemigrations accounts Em seguida edite o novo arquivo de migration gerado e adicione as dependencias corretamente, e altere o atributo de operations, veja abaixo: class Migration ( migrations . Migration ): initial = True dependencies = [ # .... outras dependencias # adicione a dependencia da migration que criamos anteriormente # no app core_aplication ( 'core_aplication' , '0002_untrack_model_person' ) ] state_operations = [ # renomeio `operaionst para `state_operations` # oprations de Create gerado pelo # comando makemigrations accounts # com os campos do model, ou caso preferir, # que voc\u00ea tenha escrito. migrations . CreateModel ( name = 'Person' , fields = [ ( 'id' , models . AutoField ( auto_created = True , primary_key = True , serialize = False , verbose_name = 'ID' )), ( 'name' , models . CharField ( max_length = 255 )), ], options = { 'db_table' : 'accounts_person' , }, ), ] # alterere o atributo `operations` para utilizar o SeparateDatabaseAndState() # e passe como argumento o state_operations, onde criamos o model operations = [ migrations . SeparateDatabaseAndState ( state_operations = state_operations ) ] Model movido com sucesso!","title":"2 - Gerar novos migrations"},{"location":"url_field_many_lookups/","text":"Django Rest UrlField com v\u00e1rios lookups \u00b6 As vezes suas url pode ter v\u00e1rios lookups que precisem ser acessado para ser mondata e achada pelo reverse do Django. Um exemplo de URL com tal comportamente \u00e9 o seguinte exemplo: https://www.domain.com/api/school/20/teacher/100/class/10/students/ A URL acima possui 3 lookups field : 20, 100 e 10. ou ainda uma URL sem lookup algum, como: https://www.domain.com/api/login/ Para adicionar um campo de URL, ao seu serializer, que seja capaz de gerar as seguinte urls ser\u00e1 preciso alguns passos a mais. Definindo a URL \u00b6 Primeiro vamos registrar nossa URL acima no arquivos urls.py # urls.py from django.urls import path from .viws import MyView url = 'api/school/<int:id_school>/teacher/<int:id_teacher>/class/<int:id_class>/students/' urlpatterns = [ path ( '' , HomeView . as_view (), name = 'home' ), path ( 'login/' , LoginView . as_view (), name = 'login' ), path ( url , MyView . as_view (), name = 'students-view' ) ] A URL acima tem os seguintes lookups keys: id_school : int id_teacher : int id_class : int Criando nosso Field \u00b6 Agora criaremos um Field dos customoizado do Django Rest que receber\u00e1 a inst\u00e2ncia do model e ir\u00e1 chamar um m\u00e9todo para criar os lookups da URL. Reverse de uma URL com v\u00e1rios lookups \u00b6 # serializers.py from rest_framework import serializers from rest_framework.reverse import reverse class UrlPatternsField ( serializers . HyperlinkedIdentityField ): def get_url ( self , obj , view_name , request , format ): kwargs = {} # nome do m\u00e9todo que deve ser implementado para # gerar os lookups da URL # ex: suponha que o field_name seja `esola` # o nome do m\u00e9todo ser\u00e1: `get_lookups_fields_escola` method_name = 'get_lookups_fields_ {} ' . format ( field_name ) # pega o m\u00e9todo, se existir. # Caso contr\u00e1rio o valor retornado \u00e9 None multiple_lookups_fields = getattr ( self . parent , method_name , None ) if multiple_lookups_fields : # j\u00e1 que existe um m\u00e9todo, passaremos o objeto # para que ele possa gerar os lookups a partir do # objeto kwargs = multiple_lookups_fields ( obj ) return reverse ( view_name , request = request , kwargs = kwargs , format = format ) Pronto, field criado, agora devemos implementar no nosso serializer. # serializers.py class ClassSerializer ( serializer . ModelSerializer ): students_url = UrlPatternsField ( view_name = 'students-view' ) # note que o nome do field deve ser adicionar ao nome do metodo # nesse caso ser\u00e1 `get_lookups_fields_students_url` class Meta : model = ClassModel fields = '__all__' def get_lookups_fields_students_url ( self , obj ): # retornamos um dict com os lookups necess\u00e1rios para # monstar a URL return { 'id_school' : obj . school . id , 'id_teacher' : obj . teacher . id , 'id_class' : obj . id } Reverse de uma URL sem lookup \u00b6 Muito simple, n\u00e3o implementamos o m\u00e9todo que retorna os lookups ou retornamos um dicion\u00e1rio vazio. # serializers.py class EntryPointSerializer ( serializer . ModelSerializer ): login = UrlPatternsField ( view_name = 'login' ) # a url nao precisa de lookups, portanto nao implementamos o metodos home = UrlPatternsField ( view_name = 'home' ) # a url nao precisa de lookups, portanto nao implementamos o metodos class Meta : model = EntryModel fields = '__all__'","title":"UrlField com v\u00e1rios lookups"},{"location":"url_field_many_lookups/#django-rest-urlfield-com-varios-lookups","text":"As vezes suas url pode ter v\u00e1rios lookups que precisem ser acessado para ser mondata e achada pelo reverse do Django. Um exemplo de URL com tal comportamente \u00e9 o seguinte exemplo: https://www.domain.com/api/school/20/teacher/100/class/10/students/ A URL acima possui 3 lookups field : 20, 100 e 10. ou ainda uma URL sem lookup algum, como: https://www.domain.com/api/login/ Para adicionar um campo de URL, ao seu serializer, que seja capaz de gerar as seguinte urls ser\u00e1 preciso alguns passos a mais.","title":"Django Rest UrlField com v\u00e1rios lookups"},{"location":"url_field_many_lookups/#definindo-a-url","text":"Primeiro vamos registrar nossa URL acima no arquivos urls.py # urls.py from django.urls import path from .viws import MyView url = 'api/school/<int:id_school>/teacher/<int:id_teacher>/class/<int:id_class>/students/' urlpatterns = [ path ( '' , HomeView . as_view (), name = 'home' ), path ( 'login/' , LoginView . as_view (), name = 'login' ), path ( url , MyView . as_view (), name = 'students-view' ) ] A URL acima tem os seguintes lookups keys: id_school : int id_teacher : int id_class : int","title":"Definindo a URL"},{"location":"url_field_many_lookups/#criando-nosso-field","text":"Agora criaremos um Field dos customoizado do Django Rest que receber\u00e1 a inst\u00e2ncia do model e ir\u00e1 chamar um m\u00e9todo para criar os lookups da URL.","title":"Criando nosso Field"},{"location":"url_field_many_lookups/#reverse-de-uma-url-com-varios-lookups","text":"# serializers.py from rest_framework import serializers from rest_framework.reverse import reverse class UrlPatternsField ( serializers . HyperlinkedIdentityField ): def get_url ( self , obj , view_name , request , format ): kwargs = {} # nome do m\u00e9todo que deve ser implementado para # gerar os lookups da URL # ex: suponha que o field_name seja `esola` # o nome do m\u00e9todo ser\u00e1: `get_lookups_fields_escola` method_name = 'get_lookups_fields_ {} ' . format ( field_name ) # pega o m\u00e9todo, se existir. # Caso contr\u00e1rio o valor retornado \u00e9 None multiple_lookups_fields = getattr ( self . parent , method_name , None ) if multiple_lookups_fields : # j\u00e1 que existe um m\u00e9todo, passaremos o objeto # para que ele possa gerar os lookups a partir do # objeto kwargs = multiple_lookups_fields ( obj ) return reverse ( view_name , request = request , kwargs = kwargs , format = format ) Pronto, field criado, agora devemos implementar no nosso serializer. # serializers.py class ClassSerializer ( serializer . ModelSerializer ): students_url = UrlPatternsField ( view_name = 'students-view' ) # note que o nome do field deve ser adicionar ao nome do metodo # nesse caso ser\u00e1 `get_lookups_fields_students_url` class Meta : model = ClassModel fields = '__all__' def get_lookups_fields_students_url ( self , obj ): # retornamos um dict com os lookups necess\u00e1rios para # monstar a URL return { 'id_school' : obj . school . id , 'id_teacher' : obj . teacher . id , 'id_class' : obj . id }","title":"Reverse de uma URL com v\u00e1rios lookups"},{"location":"url_field_many_lookups/#reverse-de-uma-url-sem-lookup","text":"Muito simple, n\u00e3o implementamos o m\u00e9todo que retorna os lookups ou retornamos um dicion\u00e1rio vazio. # serializers.py class EntryPointSerializer ( serializer . ModelSerializer ): login = UrlPatternsField ( view_name = 'login' ) # a url nao precisa de lookups, portanto nao implementamos o metodos home = UrlPatternsField ( view_name = 'home' ) # a url nao precisa de lookups, portanto nao implementamos o metodos class Meta : model = EntryModel fields = '__all__'","title":"Reverse de uma URL sem lookup"}]}